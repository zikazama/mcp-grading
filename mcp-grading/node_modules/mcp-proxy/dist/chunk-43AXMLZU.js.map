{"version":3,"sources":["../src/InMemoryEventStore.ts","../src/proxyServer.ts","../src/startHTTPStreamServer.ts","../src/startSSEServer.ts"],"sourcesContent":["/**\n * This is a copy of the InMemoryEventStore from the typescript-sdk\n * https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/inMemoryEventStore.ts\n */\n\nimport type { EventStore } from \"@modelcontextprotocol/sdk/server/streamableHttp.js\";\nimport type { JSONRPCMessage } from \"@modelcontextprotocol/sdk/types.js\";\n\n/**\n * Simple in-memory implementation of the EventStore interface for resumability\n * This is primarily intended for examples and testing, not for production use\n * where a persistent storage solution would be more appropriate.\n */\nexport class InMemoryEventStore implements EventStore {\n  private events: Map<string, { message: JSONRPCMessage; streamId: string }> =\n    new Map();\n\n  /**\n   * Replays events that occurred after a specific event ID\n   * Implements EventStore.replayEventsAfter\n   */\n  async replayEventsAfter(\n    lastEventId: string,\n    {\n      send,\n    }: { send: (eventId: string, message: JSONRPCMessage) => Promise<void> },\n  ): Promise<string> {\n    if (!lastEventId || !this.events.has(lastEventId)) {\n      return \"\";\n    }\n\n    // Extract the stream ID from the event ID\n    const streamId = this.getStreamIdFromEventId(lastEventId);\n    if (!streamId) {\n      return \"\";\n    }\n\n    let foundLastEvent = false;\n\n    // Sort events by eventId for chronological ordering\n    const sortedEvents = [...this.events.entries()].sort((a, b) =>\n      a[0].localeCompare(b[0]),\n    );\n\n    for (const [\n      eventId,\n      { message, streamId: eventStreamId },\n    ] of sortedEvents) {\n      // Only include events from the same stream\n      if (eventStreamId !== streamId) {\n        continue;\n      }\n\n      // Start sending events after we find the lastEventId\n      if (eventId === lastEventId) {\n        foundLastEvent = true;\n        continue;\n      }\n\n      if (foundLastEvent) {\n        await send(eventId, message);\n      }\n    }\n    return streamId;\n  }\n\n  /**\n   * Stores an event with a generated event ID\n   * Implements EventStore.storeEvent\n   */\n  async storeEvent(streamId: string, message: JSONRPCMessage): Promise<string> {\n    const eventId = this.generateEventId(streamId);\n    this.events.set(eventId, { message, streamId });\n    return eventId;\n  }\n\n  /**\n   * Generates a unique event ID for a given stream ID\n   */\n  private generateEventId(streamId: string): string {\n    return `${streamId}_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;\n  }\n\n  /**\n   * Extracts the stream ID from an event ID\n   */\n  private getStreamIdFromEventId(eventId: string): string {\n    const parts = eventId.split(\"_\");\n    return parts.length > 0 ? parts[0] : \"\";\n  }\n}\n","import { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport {\n  CallToolRequestSchema,\n  CompleteRequestSchema,\n  GetPromptRequestSchema,\n  ListPromptsRequestSchema,\n  ListResourcesRequestSchema,\n  ListResourceTemplatesRequestSchema,\n  ListToolsRequestSchema,\n  LoggingMessageNotificationSchema,\n  ReadResourceRequestSchema,\n  ResourceUpdatedNotificationSchema,\n  ServerCapabilities,\n  SubscribeRequestSchema,\n  UnsubscribeRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\nexport const proxyServer = async ({\n  client,\n  server,\n  serverCapabilities,\n}: {\n  client: Client;\n  server: Server;\n  serverCapabilities: ServerCapabilities;\n}): Promise<void> => {\n  if (serverCapabilities?.logging) {\n    server.setNotificationHandler(\n      LoggingMessageNotificationSchema,\n      async (args) => {\n        return client.notification(args);\n      },\n    );\n    client.setNotificationHandler(\n      LoggingMessageNotificationSchema,\n      async (args) => {\n        return server.notification(args);\n      },\n    );\n  }\n\n  if (serverCapabilities?.prompts) {\n    server.setRequestHandler(GetPromptRequestSchema, async (args) => {\n      return client.getPrompt(args.params);\n    });\n\n    server.setRequestHandler(ListPromptsRequestSchema, async (args) => {\n      return client.listPrompts(args.params);\n    });\n  }\n\n  if (serverCapabilities?.resources) {\n    server.setRequestHandler(ListResourcesRequestSchema, async (args) => {\n      return client.listResources(args.params);\n    });\n\n    server.setRequestHandler(\n      ListResourceTemplatesRequestSchema,\n      async (args) => {\n        return client.listResourceTemplates(args.params);\n      },\n    );\n\n    server.setRequestHandler(ReadResourceRequestSchema, async (args) => {\n      return client.readResource(args.params);\n    });\n\n    if (serverCapabilities?.resources.subscribe) {\n      server.setNotificationHandler(\n        ResourceUpdatedNotificationSchema,\n        async (args) => {\n          return client.notification(args);\n        },\n      );\n\n      server.setRequestHandler(SubscribeRequestSchema, async (args) => {\n        return client.subscribeResource(args.params);\n      });\n\n      server.setRequestHandler(UnsubscribeRequestSchema, async (args) => {\n        return client.unsubscribeResource(args.params);\n      });\n    }\n  }\n\n  if (serverCapabilities?.tools) {\n    server.setRequestHandler(CallToolRequestSchema, async (args) => {\n      return client.callTool(args.params);\n    });\n\n    server.setRequestHandler(ListToolsRequestSchema, async (args) => {\n      return client.listTools(args.params);\n    });\n  }\n\n  server.setRequestHandler(CompleteRequestSchema, async (args) => {\n    return client.complete(args.params);\n  });\n};\n","import { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport {\n  EventStore,\n  StreamableHTTPServerTransport,\n} from \"@modelcontextprotocol/sdk/server/streamableHttp.js\";\nimport { isInitializeRequest } from \"@modelcontextprotocol/sdk/types.js\";\nimport http from \"http\";\nimport { randomUUID } from \"node:crypto\";\n\nimport { InMemoryEventStore } from \"./InMemoryEventStore.js\";\n\nexport type SSEServer = {\n  close: () => Promise<void>;\n};\n\ntype ServerLike = {\n  close: Server[\"close\"];\n  connect: Server[\"connect\"];\n};\n\nexport const startHTTPStreamServer = async <T extends ServerLike>({\n  createServer,\n  endpoint,\n  eventStore,\n  onClose,\n  onConnect,\n  onUnhandledRequest,\n  port,\n}: {\n  createServer: (request: http.IncomingMessage) => Promise<T>;\n  endpoint: string;\n  eventStore?: EventStore;\n  onClose?: (server: T) => void;\n  onConnect?: (server: T) => void;\n  onUnhandledRequest?: (\n    req: http.IncomingMessage,\n    res: http.ServerResponse,\n  ) => Promise<void>;\n  port: number;\n}): Promise<SSEServer> => {\n  const activeTransports: Record<\n    string,\n    {\n      server: T;\n      transport: StreamableHTTPServerTransport;\n    }\n  > = {};\n\n  /**\n   * @author https://dev.classmethod.jp/articles/mcp-sse/\n   */\n  const httpServer = http.createServer(async (req, res) => {\n    if (req.headers.origin) {\n      try {\n        const origin = new URL(req.headers.origin);\n\n        res.setHeader(\"Access-Control-Allow-Origin\", origin.origin);\n        res.setHeader(\"Access-Control-Allow-Credentials\", \"true\");\n        res.setHeader(\"Access-Control-Allow-Methods\", \"GET, POST, OPTIONS\");\n        res.setHeader(\"Access-Control-Allow-Headers\", \"*\");\n      } catch (error) {\n        console.error(\"Error parsing origin:\", error);\n      }\n    }\n\n    if (req.method === \"OPTIONS\") {\n      res.writeHead(204);\n      res.end();\n      return;\n    }\n\n    if (req.method === \"GET\" && req.url === `/ping`) {\n      res.writeHead(200).end(\"pong\");\n      return;\n    }\n\n    if (\n      req.method === \"POST\" &&\n      new URL(req.url!, \"http://localhost\").pathname === endpoint\n    ) {\n      try {\n        const sessionId = Array.isArray(req.headers[\"mcp-session-id\"])\n          ? req.headers[\"mcp-session-id\"][0]\n          : req.headers[\"mcp-session-id\"];\n        let transport: StreamableHTTPServerTransport;\n        let server: T;\n\n        const body = await getBody(req);\n\n        if (sessionId && activeTransports[sessionId]) {\n          transport = activeTransports[sessionId].transport;\n          server = activeTransports[sessionId].server;\n        } else if (!sessionId && isInitializeRequest(body)) {\n          // Create a new transport for the session\n          transport = new StreamableHTTPServerTransport({\n            eventStore: eventStore || new InMemoryEventStore(),\n            onsessioninitialized: (_sessionId) => {\n              // add only when the id Sesison id is generated\n              activeTransports[_sessionId] = {\n                server,\n                transport,\n              };\n            },\n            sessionIdGenerator: randomUUID,\n          });\n\n          // Handle the server close event\n          transport.onclose = async () => {\n            const sid = transport.sessionId;\n            if (sid && activeTransports[sid]) {\n              onClose?.(server);\n              try {\n                await server.close();\n              } catch (error) {\n                console.error(\"Error closing server:\", error);\n              }\n              delete activeTransports[sid];\n            }\n          };\n\n          // Create the server\n          try {\n            server = await createServer(req);\n          } catch (error) {\n            if (error instanceof Response) {\n              res.writeHead(error.status).end(error.statusText);\n              return;\n            }\n            res.writeHead(500).end(\"Error creating server\");\n            return;\n          }\n\n          server.connect(transport);\n          onConnect?.(server);\n\n          await transport.handleRequest(req, res, body);\n          return;\n        } else {\n          // Error if the server is not created but the request is not an initialize request\n          res.setHeader(\"Content-Type\", \"application/json\");\n          res.writeHead(400).end(\n            JSON.stringify({\n              error: {\n                code: -32000,\n                message: \"Bad Request: No valid session ID provided\",\n              },\n              id: null,\n              jsonrpc: \"2.0\",\n            }),\n          );\n\n          return;\n        }\n\n        // Handle ther request if the server is already created\n        await transport.handleRequest(req, res, body);\n      } catch (error) {\n        console.error(\"Error handling request:\", error);\n        res.setHeader(\"Content-Type\", \"application/json\");\n        res.writeHead(500).end(\n          JSON.stringify({\n            error: { code: -32603, message: \"Internal Server Error\" },\n            id: null,\n            jsonrpc: \"2.0\",\n          }),\n        );\n      }\n      return;\n    }\n\n    if (\n      req.method === \"GET\" &&\n      new URL(req.url!, \"http://localhost\").pathname === endpoint\n    ) {\n      const sessionId = req.headers[\"mcp-session-id\"] as string | undefined;\n      const activeTransport:\n        | {\n            server: T;\n            transport: StreamableHTTPServerTransport;\n          }\n        | undefined = sessionId ? activeTransports[sessionId] : undefined;\n\n      if (!sessionId) {\n        res.writeHead(400).end(\"No sessionId\");\n        return;\n      }\n\n      if (!activeTransport) {\n        res.writeHead(400).end(\"No active transport\");\n        return;\n      }\n\n      const lastEventId = req.headers[\"last-event-id\"] as string | undefined;\n      if (lastEventId) {\n        console.log(`Client reconnecting with Last-Event-ID: ${lastEventId}`);\n      } else {\n        console.log(`Establishing new SSE stream for session ${sessionId}`);\n      }\n\n      await activeTransport.transport.handleRequest(req, res);\n      return;\n    }\n\n    if (\n      req.method === \"DELETE\" &&\n      new URL(req.url!, \"http://localhost\").pathname === endpoint\n    ) {\n      console.log(\"received delete request\");\n      const sessionId = req.headers[\"mcp-session-id\"] as string | undefined;\n      if (!sessionId) {\n        res.writeHead(400).end(\"Invalid or missing sessionId\");\n        return;\n      }\n\n      console.log(\"received delete request for session\", sessionId);\n\n      const { server, transport } = activeTransports[sessionId];\n      if (!transport) {\n        res.writeHead(400).end(\"No active transport\");\n        return;\n      }\n\n      try {\n        await transport.handleRequest(req, res);\n        onClose?.(server);\n      } catch (error) {\n        console.error(\"Error handling delete request:\", error);\n        res.writeHead(500).end(\"Error handling delete request\");\n      }\n\n      return;\n    }\n\n    if (onUnhandledRequest) {\n      await onUnhandledRequest(req, res);\n    } else {\n      res.writeHead(404).end();\n    }\n  });\n\n  await new Promise((resolve) => {\n    httpServer.listen(port, \"::\", () => {\n      resolve(undefined);\n    });\n  });\n\n  return {\n    close: async () => {\n      for (const transport of Object.values(activeTransports)) {\n        await transport.transport.close();\n      }\n\n      return new Promise((resolve, reject) => {\n        httpServer.close((error) => {\n          if (error) {\n            reject(error);\n\n            return;\n          }\n\n          resolve();\n        });\n      });\n    },\n  };\n};\n\nfunction getBody(request: http.IncomingMessage) {\n  return new Promise((resolve) => {\n    const bodyParts: Buffer[] = [];\n    let body: string;\n    request\n      .on(\"data\", (chunk) => {\n        bodyParts.push(chunk);\n      })\n      .on(\"end\", () => {\n        body = Buffer.concat(bodyParts).toString();\n        resolve(JSON.parse(body));\n      });\n  });\n}\n","import { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { SSEServerTransport } from \"@modelcontextprotocol/sdk/server/sse.js\";\nimport http from \"http\";\n\nexport type SSEServer = {\n  close: () => Promise<void>;\n};\n\ntype ServerLike = {\n  close: Server[\"close\"];\n  connect: Server[\"connect\"];\n};\n\nexport const startSSEServer = async <T extends ServerLike>({\n  createServer,\n  endpoint,\n  onClose,\n  onConnect,\n  onUnhandledRequest,\n  port,\n}: {\n  createServer: (request: http.IncomingMessage) => Promise<T>;\n  endpoint: string;\n  onClose?: (server: T) => void;\n  onConnect?: (server: T) => void;\n  onUnhandledRequest?: (\n    req: http.IncomingMessage,\n    res: http.ServerResponse,\n  ) => Promise<void>;\n  port: number;\n}): Promise<SSEServer> => {\n  const activeTransports: Record<string, SSEServerTransport> = {};\n\n  /**\n   * @author https://dev.classmethod.jp/articles/mcp-sse/\n   */\n  const httpServer = http.createServer(async (req, res) => {\n    if (req.headers.origin) {\n      try {\n        const origin = new URL(req.headers.origin);\n\n        res.setHeader(\"Access-Control-Allow-Origin\", origin.origin);\n        res.setHeader(\"Access-Control-Allow-Credentials\", \"true\");\n        res.setHeader(\"Access-Control-Allow-Methods\", \"GET, POST, OPTIONS\");\n        res.setHeader(\"Access-Control-Allow-Headers\", \"*\");\n      } catch (error) {\n        console.error(\"Error parsing origin:\", error);\n      }\n    }\n\n    if (req.method === \"OPTIONS\") {\n      res.writeHead(204);\n      res.end();\n      return;\n    }\n\n    if (req.method === \"GET\" && req.url === \"/health\") {\n      res.writeHead(200, { \"Content-Type\": \"text/plain\" }).end(\"OK\");\n      return;\n    }\n\n    if (req.method === \"GET\" && req.url === `/ping`) {\n      res.writeHead(200).end(\"pong\");\n\n      return;\n    }\n\n    if (\n      req.method === \"GET\" &&\n      new URL(req.url!, \"http://localhost\").pathname === endpoint\n    ) {\n      const transport = new SSEServerTransport(\"/messages\", res);\n\n      let server: T;\n\n      try {\n        server = await createServer(req);\n      } catch (error) {\n        if (error instanceof Response) {\n          res.writeHead(error.status).end(error.statusText);\n\n          return;\n        }\n\n        res.writeHead(500).end(\"Error creating server\");\n\n        return;\n      }\n\n      activeTransports[transport.sessionId] = transport;\n\n      let closed = false;\n\n      res.on(\"close\", async () => {\n        closed = true;\n\n        try {\n          await server.close();\n        } catch (error) {\n          console.error(\"Error closing server:\", error);\n        }\n\n        delete activeTransports[transport.sessionId];\n\n        onClose?.(server);\n      });\n\n      try {\n        await server.connect(transport);\n\n        await transport.send({\n          jsonrpc: \"2.0\",\n          method: \"sse/connection\",\n          params: { message: \"SSE Connection established\" },\n        });\n\n        onConnect?.(server);\n      } catch (error) {\n        if (!closed) {\n          console.error(\"Error connecting to server:\", error);\n\n          res.writeHead(500).end(\"Error connecting to server\");\n        }\n      }\n\n      return;\n    }\n\n    if (req.method === \"POST\" && req.url?.startsWith(\"/messages\")) {\n      const sessionId = new URL(\n        req.url,\n        \"https://example.com\",\n      ).searchParams.get(\"sessionId\");\n\n      if (!sessionId) {\n        res.writeHead(400).end(\"No sessionId\");\n\n        return;\n      }\n\n      const activeTransport: SSEServerTransport | undefined =\n        activeTransports[sessionId];\n\n      if (!activeTransport) {\n        res.writeHead(400).end(\"No active transport\");\n\n        return;\n      }\n\n      await activeTransport.handlePostMessage(req, res);\n\n      return;\n    }\n\n    if (onUnhandledRequest) {\n      await onUnhandledRequest(req, res);\n    } else {\n      res.writeHead(404).end();\n    }\n  });\n\n  await new Promise((resolve) => {\n    httpServer.listen(port, \"::\", () => {\n      resolve(undefined);\n    });\n  });\n\n  return {\n    close: async () => {\n      for (const transport of Object.values(activeTransports)) {\n        await transport.close();\n      }\n\n      return new Promise((resolve, reject) => {\n        httpServer.close((error) => {\n          if (error) {\n            reject(error);\n\n            return;\n          }\n\n          resolve();\n        });\n      });\n    },\n  };\n};\n"],"mappings":"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","names":["http"]}