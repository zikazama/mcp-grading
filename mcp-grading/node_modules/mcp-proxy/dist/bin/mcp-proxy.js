#!/usr/bin/env node
import {
  InMemoryEventStore,
  proxyServer,
  startHTTPStreamServer,
  startSSEServer
} from "../chunk-43AXMLZU.js";

// src/bin/mcp-proxy.ts
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { EventSource } from "eventsource";
import { setTimeout } from "timers";
import util from "util";
import yargs from "yargs";
import { hideBin } from "yargs/helpers";

// src/StdioClientTransport.ts
import {
  ReadBuffer,
  serializeMessage
} from "@modelcontextprotocol/sdk/shared/stdio.js";
import { spawn } from "child_process";
var StdioClientTransport = class {
  onclose;
  onerror;
  onmessage;
  /**
   * The stderr stream of the child process, if `StdioServerParameters.stderr` was set to "pipe" or "overlapped".
   *
   * This is only available after the process has been started.
   */
  get stderr() {
    return this.process?.stderr ?? null;
  }
  abortController = new AbortController();
  onEvent;
  process;
  readBuffer = new ReadBuffer();
  serverParams;
  constructor(server) {
    this.serverParams = server;
    this.onEvent = server.onEvent;
  }
  async close() {
    this.onEvent?.({
      type: "close"
    });
    this.abortController.abort();
    this.process = void 0;
    this.readBuffer.clear();
  }
  send(message) {
    return new Promise((resolve) => {
      if (!this.process?.stdin) {
        throw new Error("Not connected");
      }
      const json = serializeMessage(message);
      if (this.process.stdin.write(json)) {
        resolve();
      } else {
        this.process.stdin.once("drain", resolve);
      }
    });
  }
  /**
   * Starts the server process and prepares to communicate with it.
   */
  async start() {
    if (this.process) {
      throw new Error(
        "StdioClientTransport already started! If using Client class, note that connect() calls start() automatically."
      );
    }
    return new Promise((resolve, reject) => {
      this.process = spawn(
        this.serverParams.command,
        this.serverParams.args ?? [],
        {
          cwd: this.serverParams.cwd,
          env: this.serverParams.env,
          shell: false,
          signal: this.abortController.signal,
          stdio: ["pipe", "pipe", this.serverParams.stderr ?? "inherit"]
        }
      );
      this.process.on("error", (error) => {
        if (error.name === "AbortError") {
          this.onclose?.();
          return;
        }
        reject(error);
        this.onerror?.(error);
      });
      this.process.on("spawn", () => {
        resolve();
      });
      this.process.on("close", (_code) => {
        this.onEvent?.({
          type: "close"
        });
        this.process = void 0;
        this.onclose?.();
      });
      this.process.stdin?.on("error", (error) => {
        this.onEvent?.({
          error,
          type: "error"
        });
        this.onerror?.(error);
      });
      this.process.stdout?.on("data", (chunk) => {
        this.onEvent?.({
          chunk: chunk.toString(),
          type: "data"
        });
        this.readBuffer.append(chunk);
        this.processReadBuffer();
      });
      this.process.stdout?.on("error", (error) => {
        this.onEvent?.({
          error,
          type: "error"
        });
        this.onerror?.(error);
      });
    });
  }
  processReadBuffer() {
    while (true) {
      try {
        const message = this.readBuffer.readMessage();
        if (message === null) {
          break;
        }
        this.onEvent?.({
          message,
          type: "message"
        });
        this.onmessage?.(message);
      } catch (error) {
        this.onEvent?.({
          error,
          type: "error"
        });
        this.onerror?.(error);
      }
    }
  }
};

// src/bin/mcp-proxy.ts
util.inspect.defaultOptions.depth = 8;
if (!("EventSource" in global)) {
  global.EventSource = EventSource;
}
var argv = await yargs(hideBin(process.argv)).scriptName("mcp-proxy").command("$0 <command> [args...]", "Run a command with MCP arguments").positional("command", {
  demandOption: true,
  describe: "The command to run",
  type: "string"
}).positional("args", {
  array: true,
  describe: "The arguments to pass to the command",
  type: "string"
}).env("MCP_PROXY").options({
  debug: {
    default: false,
    describe: "Enable debug logging",
    type: "boolean"
  },
  endpoint: {
    describe: "The endpoint to listen on",
    type: "string"
  },
  port: {
    default: 8080,
    describe: "The port to listen on",
    type: "number"
  },
  server: {
    choices: ["sse", "stream"],
    default: "sse",
    describe: "The server type to use (sse or stream)",
    type: "string"
  }
}).help().parseAsync();
var connect = async (client) => {
  const transport = new StdioClientTransport({
    args: argv.args,
    command: argv.command,
    env: process.env,
    onEvent: (event) => {
      if (argv.debug) {
        console.debug("transport event", event);
      }
    },
    stderr: "pipe"
  });
  await client.connect(transport);
};
var proxy = async () => {
  const client = new Client(
    {
      name: "mcp-proxy",
      version: "1.0.0"
    },
    {
      capabilities: {}
    }
  );
  await connect(client);
  const serverVersion = client.getServerVersion();
  const serverCapabilities = client.getServerCapabilities();
  console.info("starting the %s server on port %d", argv.server, argv.port);
  const createServer = async () => {
    const server = new Server(serverVersion, {
      capabilities: serverCapabilities
    });
    proxyServer({
      client,
      server,
      serverCapabilities
    });
    return server;
  };
  if (argv.server === "sse") {
    await startSSEServer({
      createServer,
      endpoint: argv.endpoint || "/sse",
      port: argv.port
    });
  } else {
    await startHTTPStreamServer({
      createServer,
      endpoint: argv.endpoint || "/stream",
      eventStore: new InMemoryEventStore(),
      port: argv.port
    });
  }
};
var main = async () => {
  process.on("SIGINT", () => {
    console.info("SIGINT received, shutting down");
    setTimeout(() => {
      process.exit(0);
    }, 1e3);
  });
  try {
    await proxy();
  } catch (error) {
    console.error("could not start the proxy", error);
    setTimeout(() => {
      process.exit(1);
    }, 1e3);
  }
};
await main();
//# sourceMappingURL=mcp-proxy.js.map